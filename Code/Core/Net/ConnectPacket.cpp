// ********************************************************************
// Copyright (c) 2019 Nathan Hanlan
// 
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files(the "Software"), 
// to deal in the Software without restriction, including without limitation 
// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
// and / or sell copies of the Software, and to permit persons to whom the 
// Software is furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in 
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE 
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ********************************************************************
#include "ConnectPacket.h"
#include "Core/Common/Assert.h"
#include "Core/Crypto/AES.h"
#include "Core/Crypto/RSA.h"
#include "Core/Crypto/SecureRandom.h"
#include "Core/Crypto/SHA256.h"
#include "Core/Memory/Memory.h"
#include "Core/Net/PacketUtility.h"
#include "Core/Utility/ErrorCore.h"
#include "Core/Utility/Crc32.h"

#include <utility>

namespace lf {

struct RSAMsg
{
    // hmac key generated by client (semi-persistant)
    ByteT mHMACKey[Crypto::HMAC_KEY_SIZE];
    // iv generated for this particular message.
    ByteT mIV[Crypto::AES_IV_SIZE];
    // aes key generated by client (semi-persistant)
    ByteT mSharedKey[Crypto::AES_MAX_KEY_SIZE];
    // hmac computed from aes msg
    ByteT mHMAC[Crypto::HMAC_HASH_SIZE];
    // random bytes generated by client, used to verify on the ack
    ByteT mChallenge[ConnectPacket::CHALLENGE_SIZE];
};

struct AESMsg
{
    String mPublicKey;
};

bool ConnectPacket::EncodePacket(
    ByteT* packetBytes,
    SizeT& packetBytesLength,
    const Crypto::RSAKey& clientKey,
    const Crypto::RSAKey& serverKey,
    const Crypto::AESKey& sharedKey,
    const ByteT hmacKey[Crypto::HMAC_KEY_SIZE],
    const ByteT challenge[CHALLENGE_SIZE])
{
    // Error Handling
    if (!serverKey.HasPublicKey())
    {
        ReportBugMsg("Failed to encode connect packet. Server Key is missing a public key.");
        return false;
    }

    if (!clientKey.HasPublicKey())
    {
        ReportBugMsg("Failed to encode connect packet. Client Key is missing a public key.");
        return false;
    }

    if (sharedKey.GetKeySize() != Crypto::AES_KEY_256)
    {
        ReportBugMsg("Failed to encode connect packet. Shared Key is not the correct size.");
        return false;
    }

    if (serverKey.GetKeySize() != Crypto::RSA_KEY_2048)
    {
        ReportBugMsg("Failed to encode connect packet. Server Key is not the correct size.");
        return false;
    }

    if (clientKey.GetKeySize() != Crypto::RSA_KEY_2048)
    {
        ReportBugMsg("Failed to encode connect packet. Client Key is not the correct size.");
        return false;
    }

    const SizeT SERVER_KEY_SIZE_BYTES = serverKey.GetKeySizeBytes();
    CriticalAssert(SERVER_KEY_SIZE_BYTES == 256);

    // Declare RSA Data
    RSAMsg rsa;
    memcpy(rsa.mHMACKey, hmacKey, sizeof(rsa.mHMACKey));
    memcpy(rsa.mChallenge, challenge, sizeof(rsa.mChallenge));
    memcpy(rsa.mSharedKey, sharedKey.GetKey(), sizeof(rsa.mSharedKey));
    Crypto::SecureRandomBytes(rsa.mIV, sizeof(rsa.mIV));

    const ByteT* rsaBytes = reinterpret_cast<const ByteT*>(&rsa);
    const SizeT rsaBytesLength = sizeof(RSAMsg);
    const SizeT rsaCipherTextLength = SERVER_KEY_SIZE_BYTES;

    // Declare AES Data
    AESMsg aes;
    aes.mPublicKey = clientKey.GetPublicKey();

    const ByteT* aesBytes = reinterpret_cast<const ByteT*>(aes.mPublicKey.CStr());
    const SizeT aesBytesLength = aes.mPublicKey.Size();
    const SizeT aesCipherTextLength = Crypto::AESCipherTextLength(&sharedKey, aesBytesLength);

    // Additional error handling now that we've computed our message size.
    const SizeT messageSize = HeaderType::ACTUAL_SIZE + rsaCipherTextLength + aesCipherTextLength;
    if (!packetBytes)
    {
        return false;
    }

    if (packetBytesLength < messageSize)
    {
        return false;
    }
    
    HeaderType* header = reinterpret_cast<HeaderType*>(packetBytes);
    ByteT* outAES = &header->mPadding[rsaCipherTextLength];
    SizeT outAESSize = aesCipherTextLength;
    ByteT* outRSA = &header->mPadding[0];
    SizeT outRSASize = rsaCipherTextLength;

    // Write AES
    if (!Crypto::AESEncrypt(&sharedKey, rsa.mIV, aesBytes, aesBytesLength, outAES, outAESSize))
    {
        return false;
    }

    if (outAESSize != aesCipherTextLength)
    {
        ReportBug("Unexpected AES cipher text size.");
    }
    

    // Write RSA
    if (!Crypto::HMACCompute(rsa.mHMACKey, outAES, outAESSize, rsa.mHMAC))
    {
        return false;
    }
    if (!Crypto::RSAEncryptPublic(&serverKey, rsaBytes, rsaBytesLength, outRSA, outRSASize))
    {
        return false;
    }

    if (outRSASize != rsaCipherTextLength)
    {
        ReportBug("Unexpected RSA cipher text size.");
    }

    // Write Header
    header->mAppID = NetConfig::NET_APP_ID;
    header->mAppVersion = NetConfig::NET_APP_VERSION;
    header->mFlags = 0;
    header->mType = NetPacketType::NET_PACKET_TYPE_CONNECT;
    header->mCrc32 = PacketUtility::CalcCrc32(packetBytes, messageSize);

    packetBytesLength = messageSize;
    return true;
}

bool ConnectPacket::DecodePacket(
    const ByteT* packetBytes,
    SizeT packetBytesLength,
    const Crypto::RSAKey& serverKey,
    Crypto::RSAKey& clientKey,
    Crypto::AESKey& sharedKey,
    ByteT hmacKey[Crypto::HMAC_KEY_SIZE],
    ByteT challenge[CHALLENGE_SIZE],
    HeaderType& header)
{
    if (!packetBytes)
    {
        return false;
    }

    if (!serverKey.HasPrivateKey())
    {
        ReportBugMsg("Failed to decode connect packet. Server Key is missing private key.");
        return false;
    }

    if (serverKey.GetKeySize() != Crypto::RSA_KEY_2048)
    {
        ReportBugMsg("Failed to decode connect packet. Server Key is not the correct size.");
        return false;
    }

    const SizeT SERVER_KEY_SIZE_BYTES = serverKey.GetKeySizeBytes();
    CriticalAssert(SERVER_KEY_SIZE_BYTES == 256);

    if (packetBytesLength < (HeaderType::ACTUAL_SIZE + SERVER_KEY_SIZE_BYTES))
    {
        ReportBug("Failed to decode connect packet. Packet is not a connect packet type.");
        return false;
    }

    const SizeT rsaCipherTextLength = SERVER_KEY_SIZE_BYTES;
    const SizeT aesCipherTextLength = packetBytesLength - (HeaderType::ACTUAL_SIZE + SERVER_KEY_SIZE_BYTES);

    // 
    const HeaderType* packetHeader = reinterpret_cast<const HeaderType*>(packetBytes);
    if (packetHeader->mAppID != NetConfig::NET_APP_ID)
    {
        return false;
    }

    if (packetHeader->mAppVersion != NetConfig::NET_APP_VERSION)
    {
        return false;
    }

    if (packetHeader->mCrc32 != PacketUtility::CalcCrc32(packetBytes, packetBytesLength))
    {
        return false;
    }

    if (packetHeader->mType != NetPacketType::NET_PACKET_TYPE_CONNECT)
    {
        return false;
    }

    if (NetPacketFlag::BitfieldType(packetHeader->mFlags).Has(NetPacketFlag::NET_PACKET_FLAG_ACK))
    {
        return false;
    }

    const ByteT* rsaBytes = packetBytes + (HeaderType::ACTUAL_SIZE);
    const ByteT* aesBytes = packetBytes + (HeaderType::ACTUAL_SIZE + rsaCipherTextLength);

    ByteT rsaPlainText[257];
    SizeT rsaPlainTextSize = sizeof(rsaPlainText) - 1;
    ByteT aesPlainText[4097];
    SizeT aesPlainTextSize = sizeof(aesPlainText) - 1;

    // RSA
    if (!Crypto::RSADecryptPrivate(&serverKey, rsaBytes, rsaCipherTextLength, rsaPlainText, rsaPlainTextSize) || rsaPlainTextSize != sizeof(RSAMsg))
    {
        return false;
    }
    rsaPlainText[rsaPlainTextSize] = 0;
    
    RSAMsg* rsa = reinterpret_cast<RSAMsg*>(rsaPlainText);
    
    // Verify
    ByteT hmac[Crypto::HMAC_HASH_SIZE];
    if (!Crypto::HMACCompute(rsa->mHMACKey, aesBytes, aesCipherTextLength, hmac) || memcmp(rsa->mHMAC, hmac, sizeof(hmac)) != 0)
    {
        return false;
    }

    if (!sharedKey.Load(Crypto::AES_KEY_256, rsa->mSharedKey))
    {
        return false;
    }

    // AES
    if (!Crypto::AESDecrypt(&sharedKey, rsa->mIV, aesBytes, aesCipherTextLength, aesPlainText, aesPlainTextSize))
    {
        return false;
    }
    aesPlainText[aesPlainTextSize] = 0;

    String publicKey(aesPlainTextSize, reinterpret_cast<const char*>(aesPlainText), COPY_ON_WRITE);
    if (!clientKey.LoadPublicKey(publicKey))
    {
        return false;
    }

    memcpy(challenge, rsa->mChallenge, sizeof(rsa->mChallenge));
    memcpy(hmacKey, rsa->mHMACKey, sizeof(rsa->mHMACKey));
    header = *packetHeader;
    return true;
}

struct RSAAckMsg
{
    ByteT mIV[16];
    ByteT mHMAC[Crypto::HMAC_HASH_SIZE];
    ByteT mChallenge[32];
    ByteT mServerNonce[32];
    ConnectionID mID;
};

struct AESAckMsg
{
    String mPublicKey; // For the unique key
};

bool ConnectPacket::EncodeAckPacket(
    ByteT* packetBytes,
    SizeT& packetBytesLength,
    const Crypto::RSAKey& clientKey,
    const Crypto::RSAKey& uniqueKey,
    const Crypto::AESKey& sharedKey,
    const ByteT hmacKey[Crypto::HMAC_KEY_SIZE],
    const ByteT challenge[CHALLENGE_SIZE],
    const ByteT serverNonce[NONCE_SIZE],
    ConnectionID connectionID)
{
    if (!clientKey.HasPublicKey())
    {
        ReportBugMsg("Failed to encode connect ack packet. Client Key is missing public key.");
        return false;
    }

    if (!uniqueKey.HasPublicKey())
    {
        ReportBugMsg("Failed to encode connect ack packet. Unique Key is missing public key.");
        return false;
    }

    if (sharedKey.GetKeySize() != Crypto::AES_KEY_256)
    {
        ReportBugMsg("Failed to encode connect ack packet. Shared Key is not the correct size.");
        return false;
    }

    if (clientKey.GetKeySize() != Crypto::RSA_KEY_2048)
    {
        ReportBugMsg("Failed to encode connect ack packet. Client Key is not the correct size.");
        return false;
    }

    if (uniqueKey.GetKeySize() != Crypto::RSA_KEY_2048)
    {
        ReportBugMsg("Failed to encode connect ack packet. UniqueKey Key is not the correct size.");
        return false;
    }

    const SizeT CLIENT_KEY_SIZE_BYTES = clientKey.GetKeySizeBytes();
    CriticalAssert(CLIENT_KEY_SIZE_BYTES == 256);

    // RSA
    RSAAckMsg rsa;
    memcpy(rsa.mChallenge, challenge, sizeof(rsa.mChallenge));
    memcpy(rsa.mServerNonce, serverNonce, sizeof(rsa.mServerNonce));
    rsa.mID = connectionID;
    Crypto::SecureRandomBytes(rsa.mIV, sizeof(rsa.mIV));

    const ByteT* rsaBytes = reinterpret_cast<const ByteT*>(&rsa);
    const SizeT rsaBytesLength = sizeof(RSAAckMsg);
    const SizeT rsaCipherTextLength = CLIENT_KEY_SIZE_BYTES;

    // AES
    AESAckMsg aes;
    aes.mPublicKey = uniqueKey.GetPublicKey();

    const ByteT* aesBytes = reinterpret_cast<const ByteT*>(aes.mPublicKey.CStr());
    const SizeT aesBytesLength = aes.mPublicKey.Size();
    const SizeT aesCipherTextLength = Crypto::AESCipherTextLength(&sharedKey, aesBytesLength);

    const SizeT messageSize = AckHeaderType::ACTUAL_SIZE + rsaCipherTextLength + aesCipherTextLength;
    if (!packetBytes)
    {
        return false;
    }

    if (packetBytesLength < messageSize)
    {
        return false;
    }

    AckHeaderType* header = reinterpret_cast<AckHeaderType*>(packetBytes);
    ByteT* outAES = &(&header->mPadding)[rsaCipherTextLength];
    SizeT outAESSize = aesCipherTextLength;
    ByteT* outRSA = &header->mPadding;
    SizeT outRSASize = rsaCipherTextLength;

    // Write AES
    if (!Crypto::AESEncrypt(&sharedKey, rsa.mIV, aesBytes, aesBytesLength, outAES, outAESSize))
    {
        return false;
    }

    if (outAESSize != aesCipherTextLength)
    {
        ReportBugMsg("Unepxected AES cipher text size.");
    }

    if (!Crypto::HMACCompute(hmacKey, outAES, outAESSize, rsa.mHMAC))
    {
        return false;
    }

    // Write RSA
    if (!Crypto::RSAEncryptPublic(&clientKey, rsaBytes, rsaBytesLength, outRSA, outRSASize))
    {
        return false;
    }

    if (outRSASize != rsaCipherTextLength)
    {
        ReportBugMsg("Unexpected RSA cipher text size.");
    }

    // Write Header
    header->mAppID = NetConfig::NET_APP_ID;
    header->mAppVersion = NetConfig::NET_APP_VERSION;
    header->mFlags = NetPacketFlag::BitfieldType({ NetPacketFlag::NET_PACKET_FLAG_ACK }).value;
    header->mType = NetPacketType::NET_PACKET_TYPE_CONNECT;
    header->mStatus = NetAckStatus::NET_ACK_STATUS_OK;
    header->mCrc32 = PacketUtility::CalcCrc32(packetBytes, messageSize);

    packetBytesLength = messageSize;
    return true;
}

bool ConnectPacket::DecodeAckPacket(
    const ByteT* packetBytes,
    SizeT packetBytesLength,
    const Crypto::RSAKey& clientKey,
    Crypto::RSAKey& uniqueKey,
    const Crypto::AESKey& sharedKey,
    const ByteT hmacKey[Crypto::HMAC_KEY_SIZE],
    ByteT challenge[CHALLENGE_SIZE],
    ByteT serverNonce[NONCE_SIZE],
    ConnectionID& connectionID,
    AckHeaderType& header)
{
    if (!clientKey.HasPrivateKey())
    {
        ReportBugMsg("Failed to decode connect ack packet. Client Key is missing private key.");
        return false;
    }

    if (clientKey.GetKeySize() != Crypto::RSA_KEY_2048)
    {
        ReportBugMsg("Failed to decode connect ack packet.  Client Key is not the correct size.");
        return false;
    }

    if (sharedKey.GetKeySize() != Crypto::AES_KEY_256)
    {
        ReportBugMsg("Failed to decode connect ack packet.  Shared Key is not the correct size.");
        return false;
    }

    const SizeT CLIENT_KEY_SIZE_BYTES = clientKey.GetKeySizeBytes();
    CriticalAssert(CLIENT_KEY_SIZE_BYTES == 256);

    if (packetBytesLength < (AckHeaderType::ACTUAL_SIZE + CLIENT_KEY_SIZE_BYTES))
    {
        ReportBug("Failed to decode connect packet. Packet is not a ack connect packet type.");
        return false;
    }

    const SizeT rsaCipherTextLength = CLIENT_KEY_SIZE_BYTES;
    const SizeT aesCipherTextLength = packetBytesLength - (AckHeaderType::ACTUAL_SIZE + CLIENT_KEY_SIZE_BYTES);

    // Check Header:
    const AckHeaderType* packetHeader = reinterpret_cast<const AckHeaderType*>(packetBytes);
    if (packetHeader->mAppID != NetConfig::NET_APP_ID)
    {
        return false;
    }

    if (packetHeader->mAppVersion != NetConfig::NET_APP_VERSION)
    {
        return false;
    }

    if (packetHeader->mCrc32 != PacketUtility::CalcCrc32(packetBytes, packetBytesLength))
    {
        return false;
    }

    if (packetHeader->mType != NetPacketType::NET_PACKET_TYPE_CONNECT)
    {
        return false;
    }

    if (!NetPacketFlag::BitfieldType(packetHeader->mFlags).Has(NetPacketFlag::NET_PACKET_FLAG_ACK))
    {
        return false;
    }

    const ByteT* rsaBytes = packetBytes + (AckHeaderType::ACTUAL_SIZE);
    const ByteT* aesBytes = packetBytes + (AckHeaderType::ACTUAL_SIZE + rsaCipherTextLength);

    ByteT rsaPlainText[257];
    SizeT rsaPlainTextSize = sizeof(rsaPlainText) - 1;
    ByteT aesPlainText[4097];
    SizeT aesPlainTextSize = sizeof(aesPlainText) - 1;

    // Decode RSA
    if (!Crypto::RSADecryptPrivate(&clientKey, rsaBytes, rsaCipherTextLength, rsaPlainText, rsaPlainTextSize))
    {
        return false;
    }
    rsaPlainText[rsaPlainTextSize] = 0;

    RSAAckMsg* rsa = reinterpret_cast<RSAAckMsg*>(rsaPlainText);
    // Verify
    ByteT hmac[Crypto::HMAC_HASH_SIZE];
    if (!Crypto::HMACCompute(hmacKey, aesBytes, aesCipherTextLength, hmac) || memcmp(rsa->mHMAC, hmac, sizeof(hmac)) != 0)
    {
        return false;
    }

    // Decode AES
    if (!Crypto::AESDecrypt(&sharedKey, rsa->mIV, aesBytes, aesCipherTextLength, aesPlainText, aesPlainTextSize))
    {
        return false;
    }
    aesPlainText[aesPlainTextSize] = 0;

    // Deliver Header|Challenge|UniqueKey
    String publicKey(aesPlainTextSize, reinterpret_cast<const char*>(aesPlainText), COPY_ON_WRITE);
    if (!uniqueKey.LoadPublicKey(publicKey))
    {
        return false;
    }
    memcpy(challenge, rsa->mChallenge, sizeof(rsa->mChallenge));
    memcpy(serverNonce, rsa->mServerNonce, sizeof(rsa->mServerNonce));
    connectionID = rsa->mID;
    header = *packetHeader;
    return true;
}

} // namespace lf